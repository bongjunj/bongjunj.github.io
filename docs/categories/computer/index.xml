<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer on Bongjun Jang</title>
    <link>https://bongjunj.github.io/categories/computer/</link>
    <description>Recent content in Computer on Bongjun Jang</description>
    <generator>Hugo</generator>
    <language>ko</language>
    <managingEditor>bongjun.jang [at] kaist.ac.kr (Bongjun Jang)</managingEditor>
    <webMaster>bongjun.jang [at] kaist.ac.kr (Bongjun Jang)</webMaster>
    <lastBuildDate>Mon, 29 Nov 2021 08:54:51 +0900</lastBuildDate>
    <atom:link href="https://bongjunj.github.io/categories/computer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>액터 모델 실습</title>
      <link>https://bongjunj.github.io/posts/actor-model-in-practice/</link>
      <pubDate>Mon, 29 Nov 2021 08:54:51 +0900</pubDate><author>bongjun.jang [at] kaist.ac.kr (Bongjun Jang)</author>
      <guid>https://bongjunj.github.io/posts/actor-model-in-practice/</guid>
      <description>&lt;figure&gt;&#xA;  &lt;center&gt;&#xA;    &lt;img&#xA;      srcset=&#39;&#xA;    /posts/actor-model-in-practice/elixir-lang_hu14571372750623140476.png 320w,&#xA;    /posts/actor-model-in-practice/elixir-lang_hu18234824265439978789.png 600w,&#xA;    /posts/actor-model-in-practice/elixir-lang_hu12460540374961066020.png 900w,&#xA;    /posts/actor-model-in-practice/elixir-lang_hu15549662557914904504.png 1200x&#39;&#xA;      sizes=&#34;(max-width: 320px) 280px, (max-width: 600px) 560px, 800px&#34;&#xA;      src=&#39;https://bongjunj.github.io/posts/actor-model-in-practice/elixir-lang_hu18234824265439978789.png&#39;&#xA;      alt=&#34;&#34;&#xA;    /&gt;&#xA;    &lt;figcaption&gt;&#xA;      &lt;p&gt;Elixir Programming Language&lt;/p&gt;&#xA;    &lt;/figcaption&gt;&#xA;  &lt;/center&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&#xA;&lt;p&gt;요즘 나의 프로그래밍 공부는 Elixir를 공부하는 데 치중되어 있다.&#xA;Elixir는 강타입(Strongly typed), 동적타입(Dynamically typed), 함수형(Functional) 프로그래밍 언어다.&#xA;컴파일(&lt;code&gt;elixirc&lt;/code&gt;) 뿐 아니라 인터랙티브 쉘(&lt;code&gt;iex&lt;/code&gt;)과 스크립팅(&lt;code&gt;exs&lt;/code&gt;)도 지원하기 때문에&#xA;함수형 언어인 것만 제외하면 파이썬이나 루비와 같은 스크립트 언어처럼 사용할 수 있다.&#xA;실제로 문법도 루비와 매우 흡사하기 때문에 파이썬이나 루비를 배웠던 사람이라면 큰 어려움없이 흡수할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>쿠키런 킹덤 서버 아키텍처 3</title>
      <link>https://bongjunj.github.io/posts/cookie-run-kingdom-server-architecture-3/</link>
      <pubDate>Tue, 31 Aug 2021 14:55:09 +0900</pubDate><author>bongjun.jang [at] kaist.ac.kr (Bongjun Jang)</author>
      <guid>https://bongjunj.github.io/posts/cookie-run-kingdom-server-architecture-3/</guid>
      <description>&lt;p&gt;세번쨰 주제에서 함수형 프로그래밍에 대한 이야기가 눈에 띈다.&#xA;영상에서 소개되는 &amp;lsquo;프로그램&amp;rsquo;이라는 개념은 함수형 프로그래밍의 &amp;lsquo;순수 함수&amp;rsquo;라는 개념과 동일하다.&#xA;또한 Scala의 DSL 기능이 보이는데, 어떻게 작동하는지 다시 살펴보자. 기억이 가물가물하다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;pure-function순수-함수&#34;&gt;Pure Function(순수 함수)&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;figure&gt;&#xA;  &lt;center&gt;&#xA;    &lt;img&#xA;      srcset=&#39;&#xA;    /posts/cookie-run-kingdom-server-architecture-3/pure_function_hu1541585541557306700.png 320w,&#xA;    /posts/cookie-run-kingdom-server-architecture-3/pure_function_hu5585606918568833374.png 600w,&#xA;    /posts/cookie-run-kingdom-server-architecture-3/pure_function_hu3198839656501255271.png 900w,&#xA;    /posts/cookie-run-kingdom-server-architecture-3/pure_function_hu1973683172689697117.png 1200x&#39;&#xA;      sizes=&#34;(max-width: 320px) 280px, (max-width: 600px) 560px, 800px&#34;&#xA;      src=&#39;https://bongjunj.github.io/posts/cookie-run-kingdom-server-architecture-3/pure_function_hu5585606918568833374.png&#39;&#xA;      alt=&#34;pure function diagram&#34;&#xA;    /&gt;&#xA;    &lt;figcaption&gt;&#xA;      &lt;p&gt;&lt;/p&gt;&#xA;    &lt;/figcaption&gt;&#xA;  &lt;/center&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&#xA;&lt;p&gt;함수가 순수하다는 말은 함수가 같은 입력에 대해서 항상 같은 결과값을 만들며, 부작용(side effect)이 없다는 뜻이다.&#xA;여기서 부작용이란 함수의 &amp;lsquo;보이지 않는 결과값&amp;rsquo;이라고 할 수 있는데, 함수 외부의 가변 변수를 수정한다든지, 시스템의 상태를 변경시킨다던지 하는 것들을 말한다.&#xA;순수 함수를 통해 우리는 함수가 오로지 입력과 결과값만을 통해 외부와 소통할 수 있음을 보장할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>쿠키런 킹덤 서버 아키텍처 2</title>
      <link>https://bongjunj.github.io/posts/cookie-run-kingdom-server-architecture-2/</link>
      <pubDate>Mon, 30 Aug 2021 20:19:15 +0900</pubDate><author>bongjun.jang [at] kaist.ac.kr (Bongjun Jang)</author>
      <guid>https://bongjunj.github.io/posts/cookie-run-kingdom-server-architecture-2/</guid>
      <description>&lt;p&gt;이번 포스트에서 다룰 내용은 CRUD와 Event Sourcing이다.&#xA;이 주제는 데이터를 다루는 방법에 대한 이야기다.&lt;/p&gt;&#xA;&lt;p&gt;가장 간단한 예로 은행 계좌를 관리하는 어플리케이션을 생각해보자.&#xA;은행 계좌는 잔액를 관리해야하며 계좌 간의 송금 기능을 구현해야 한다.&#xA;이를 CRUD와 Event Sourcing으로 각각 구현해보자.&lt;/p&gt;&#xA;&lt;h2 id=&#34;crud&#34;&gt;CRUD&lt;/h2&gt;&#xA;&lt;p&gt;CRUD는 Create, Read, Update and Delete의 약어로 데이터를 생성하고 읽고 수정하고 삭제하는 기능을 말한다.&#xA;F#으로 CRUD를 나타내보면 다음과 같은 코드로 나타낼 수 있을 것이다.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 1. Create&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mutable account &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; BankAccount&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;500&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2. Read&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;printfn &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Balance: %d USD&amp;#34;&lt;/span&gt; account&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Balance&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 3. Update&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;account&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Deposit&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;100&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;account&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SendTo&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;otherAccount&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 200&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 4. Delete&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;account&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Destroy()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;CRUD는 어플리케이션의 구조가 가장 직관적이라는 장점이 있다.&#xA;실제 세계에서 은행 계좌를 개설하고, 입출금하고 송금하고, 계좌를 폐쇄하는 것처럼&#xA;프로그램을 작성할 때도 그대로 기능을 구현하면 되기 때문에 이해하기가 쉽다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>쿠키런 킹덤 서버 아키텍처 1</title>
      <link>https://bongjunj.github.io/posts/cookie-run-kingdom-server-architecture-1/</link>
      <pubDate>Sun, 29 Aug 2021 12:37:24 +0900</pubDate><author>bongjun.jang [at] kaist.ac.kr (Bongjun Jang)</author>
      <guid>https://bongjunj.github.io/posts/cookie-run-kingdom-server-architecture-1/</guid>
      <description>&lt;p&gt;Actor Model에 대해서 정리하며 포스트를 쓰려다가 예전에 봤던 &lt;a href=&#34;https://www.youtube.com/watch?v=FUEZibcZEkg&#34;&gt;NDC21-프로그래밍, 쿠키런 킹덤 서버 아키텍처 뜯어먹기&lt;/a&gt;가 떠올라서 리뷰해보려고 한다.&#xA;서버 아키텍처에 대해 많은 내용을 배울 수 있는 자료라서 좋은 공부가 될 것 같다.&lt;/p&gt;&#xA;&#xA;&#xA;    &#xA;    &lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;&#xA;      &lt;iframe allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&#34; allowfullscreen=&#34;allowfullscreen&#34; loading=&#34;eager&#34; referrerpolicy=&#34;strict-origin-when-cross-origin&#34; src=&#34;https://www.youtube.com/embed/FUEZibcZEkg?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; title=&#34;[NDC21-프로그래밍] 〈쿠키런: 킹덤〉 서버 아키텍처 뜯어먹기!&#34;&#xA;      &gt;&lt;/iframe&gt;&#xA;    &lt;/div&gt;&#xA;&#xA;&lt;p&gt;일단 영상의 주요 내용은 다음과 같다. (영상 1분 16초 참고)&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Stateful vs. Stateless, and Actor Model&lt;/li&gt;&#xA;&lt;li&gt;CRUD vs. Event Sourcing&lt;/li&gt;&#xA;&lt;li&gt;함수형 프로그래밍과 DSL로 콘텐츠 구현&lt;/li&gt;&#xA;&lt;li&gt;유저간 상호 작용 구현하기: 2PC vs. SAGA&lt;/li&gt;&#xA;&lt;li&gt;이벤트 기반 아키텍처를 바탕으로 확장하기&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;이번 포스트에서는 첫번째 내용을 다뤄보려고 한다.&#xA;첫번째 내용만 해도 다룰 이야기가 참 많다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>컴퓨터와 시간</title>
      <link>https://bongjunj.github.io/posts/computer-and-time/</link>
      <pubDate>Sat, 28 Aug 2021 12:35:23 +0900</pubDate><author>bongjun.jang [at] kaist.ac.kr (Bongjun Jang)</author>
      <guid>https://bongjunj.github.io/posts/computer-and-time/</guid>
      <description>&lt;figure&gt;&#xA;  &lt;center&gt;&#xA;    &lt;img&#xA;      srcset=&#39;&#xA;    /posts/computer-and-time/pat_sync_hu15267781798033968347.jpg 320w,&#xA;    /posts/computer-and-time/pat_sync_hu6411697782156098745.jpg 600w,&#xA;    /posts/computer-and-time/pat_sync_hu14209291878614924466.jpg 900w,&#xA;    /posts/computer-and-time/pat_sync_hu871492035835143153.jpg 1200x&#39;&#xA;      sizes=&#34;(max-width: 320px) 280px, (max-width: 600px) 560px, 800px&#34;&#xA;      src=&#39;https://bongjunj.github.io/posts/computer-and-time/pat_sync_hu6411697782156098745.jpg&#39;&#xA;      alt=&#34;&#34;&#xA;    /&gt;&#xA;    &lt;figcaption&gt;&#xA;      &lt;p&gt;&lt;/p&gt;&#xA;    &lt;/figcaption&gt;&#xA;  &lt;/center&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&#xA;&lt;h1 id=&#34;거대한-시차&#34;&gt;거대한 시차&lt;/h1&gt;&#xA;&lt;p&gt;해외로 가는 비행기표를 찾아볼 때 우리는 우리의 표준시와 도착지의 표준시를 비교한다.&#xA;서울은 뉴욕보다 14시간 빠르다.&#xA;일광절약제가 적용되는 때에는 13시간 빠르다.&#xA;그래서 인천에서 출발할 때의 시각은 한국표준시로 읽고 뉴욕에 도착할 때의 시각은 동부시간대로 읽는다.&#xA;지구 상에 어디에 있든, 시간대는 아주 정확하게 구분되어 있고 일정한 간격으로 흘러가고 있다.&lt;/p&gt;&#xA;&lt;p&gt;현대 사회에서 시각을 읽는 것은 아주 쉬운 일이다.&#xA;스마트 워치를 사용하거나, 스마트폰을 열거나 랩탑이나 데스크탑을 키면 1초단위로 시각을 아주 정확하게 보여준다.&#xA;콘서트 티케팅이나 대학 수강신청처럼 1초 단위로 희비가 갈리는 이벤트에 있어서도&#xA;다들 디지털 시계를 가지고 있기 때문에 티케팅 서버나 대학 서버 시각을 정확하게 맞춰서 접속할 수 있다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
